-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_3 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic );
end MUX_GATE_3;

architecture Behavioral of MUX_GATE_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF is
  generic (
    Default: std_logic ); 
  port ( D  : in std_logic;
         C  : in std_logic;
         Q  : out std_logic;
         notQ : out std_logic );
end DIG_D_FF;

architecture Behavioral of DIG_D_FF is
   signal state : std_logic := Default;
begin
   Q    <= state;
   notQ <= NOT( state );

   process(C)
   begin
      if rising_edge(C) then
        state  <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    RSh: in std_logic;
    L: in std_logic;
    CLK: in std_logic;
    LSh: in std_logic;
    D0: in std_logic;
    D1: in std_logic;
    D2: in std_logic;
    D3: in std_logic;
    SI: in std_logic;
    Q3: out std_logic;
    Q2: out std_logic;
    Q1: out std_logic;
    Q0: out std_logic;
    x3: out std_logic;
    x2: out std_logic;
    x1: out std_logic;
    x0: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic_vector(2 downto 0);
  signal Q3_temp: std_logic;
  signal Q2_temp: std_logic;
  signal s1: std_logic;
  signal s2: std_logic_vector(2 downto 0);
  signal Q1_temp: std_logic;
  signal s3: std_logic;
  signal s4: std_logic_vector(2 downto 0);
  signal Q0_temp: std_logic;
  signal s5: std_logic;
  signal s6: std_logic_vector(2 downto 0);
  signal s7: std_logic;
begin
  s0(0) <= L;
  s0(1) <= RSh;
  s0(2) <= LSh;
  s2(0) <= L;
  s2(1) <= RSh;
  s2(2) <= LSh;
  s4(0) <= L;
  s4(1) <= RSh;
  s4(2) <= LSh;
  s6(0) <= L;
  s6(1) <= RSh;
  s6(2) <= LSh;
  gate0: entity work.MUX_GATE_3
    port map (
      sel => s0,
      in_0 => Q3_temp,
      in_1 => D3,
      in_2 => SI,
      in_3 => SI,
      in_4 => Q2_temp,
      in_5 => Q2_temp,
      in_6 => Q3_temp,
      in_7 => Q3_temp,
      p_out => s1);
  gate1: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s1,
      C => CLK,
      Q => Q3_temp,
      notQ => x3);
  gate2: entity work.MUX_GATE_3
    port map (
      sel => s2,
      in_0 => Q2_temp,
      in_1 => D2,
      in_2 => Q3_temp,
      in_3 => Q3_temp,
      in_4 => Q1_temp,
      in_5 => Q1_temp,
      in_6 => Q2_temp,
      in_7 => Q2_temp,
      p_out => s3);
  gate3: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s3,
      C => CLK,
      Q => Q2_temp,
      notQ => x2);
  gate4: entity work.MUX_GATE_3
    port map (
      sel => s4,
      in_0 => Q1_temp,
      in_1 => D1,
      in_2 => Q2_temp,
      in_3 => Q2_temp,
      in_4 => Q0_temp,
      in_5 => Q0_temp,
      in_6 => Q1_temp,
      in_7 => Q1_temp,
      p_out => s5);
  gate5: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s5,
      C => CLK,
      Q => Q1_temp,
      notQ => x1);
  gate6: entity work.MUX_GATE_3
    port map (
      sel => s6,
      in_0 => Q0_temp,
      in_1 => D0,
      in_2 => Q1_temp,
      in_3 => Q1_temp,
      in_4 => SI,
      in_5 => SI,
      in_6 => Q0_temp,
      in_7 => Q0_temp,
      p_out => s7);
  gate7: entity work.DIG_D_FF
    generic map (
      Default => '0')
    port map (
      D => s7,
      C => CLK,
      Q => Q0_temp,
      notQ => x0);
  Q3 <= Q3_temp;
  Q2 <= Q2_temp;
  Q1 <= Q1_temp;
  Q0 <= Q0_temp;
end Behavioral;
